# Effect of MPAs

```{r required, echo=FALSE,message=FALSE}
library(fields)
library(lattice)
library(colorspace)
require(RCurl)
require(ggplot2)
require(ggthemes)
require(plyr)
require(reshape2)
```
Have noticed that there's a section of parameter space in which the `Equil.pop` varies in the `consMPA` simulations. Why is that?

```{r loadData, echo=FALSE, message=FALSE}
# for synced online github data
   x = getURL("https://raw.github.com/emfuller/MovingFish/master/Simluations/Aspatial_fast/Data/MPAnull_2013-12-09.csv?token=3235371__eyJzY29wZSI6IlJhd0Jsb2I6ZW1mdWxsZXIvTW92aW5nRmlzaC9tYXN0ZXIvU2ltbHVhdGlvbnMvQXNwYXRpYWxfZmFzdC9EYXRhL01QQW51bGxfMjAxMy0xMi0wOS5jc3YiLCJleHBpcmVzIjoxMzkyODI5NjEzfQ%3D%3D--9fbc7c170a93836981fa63448bf378fbbdb13905")
  sim = read.csv(textConnection(x))

  fish = getURL("https://raw.github.com/emfuller/MovingFish/master/Simluations/Aspatial_fast/Data/MPAfish_2013-12-09.csv?token=3235371__eyJzY29wZSI6IlJhd0Jsb2I6ZW1mdWxsZXIvTW92aW5nRmlzaC9tYXN0ZXIvU2ltbHVhdGlvbnMvQXNwYXRpYWxfZmFzdC9EYXRhL01QQWZpc2hfMjAxMy0xMi0wOS5jc3YiLCJleHBpcmVzIjoxMzkyODI5NjQzfQ%3D%3D--a432e4025f1b9042246c8a3d6b49af3464a03546")
  fishmpa = read.csv(textConnection(fish))

  cons = getURL("https://raw.github.com/emfuller/MovingFish/master/Simluations/Aspatial_fast/Data/MPAcons_2014-02-10.csv?token=3235371__eyJzY29wZSI6IlJhd0Jsb2I6ZW1mdWxsZXIvTW92aW5nRmlzaC9tYXN0ZXIvU2ltbHVhdGlvbnMvQXNwYXRpYWxfZmFzdC9EYXRhL01QQWNvbnNfMjAxNC0wMi0xMC5jc3YiLCJleHBpcmVzIjoxMzkyODI5NjYwfQ%3D%3D--00004e8d0186aa3a6f7f52bb264a406f147d1abf")
  consmpa = read.csv(textConnection(cons))

# combine all data into one dataframe
sim$management = rep("noManagement",nrow(sim))
consmpa$management = rep("consMPA", nrow(consmpa))
fishmpa$management = rep("fishMPA", nrow(fishmpa))

allData <- rbind(sim,consmpa,fishmpa)
```
Map equilibrium harvest as function of speed of climate velocity and harvest rate.

```{r Compare_Management,echo = FALSE, fig.width=10, fig.height=10}
contourplot(Equil.pop ~ speed * harvest | factor(management), data = allData, region=TRUE, layout = c(1,3), drape=TRUE)

```

Looks like conservation MPAs do the best, but there are some weird fluctuations at higher harvest rates, why is that? Can take slices to look more closely

```{r variance, echo = FALSE, fig.width=10, fig.height=5}
subData <- subset(allData,harvest == 0.04 )
pd <- position_dodge(.1)
ggplot(subData, aes(x = speed, y = Equil.pop))+ facet_wrap(~management) + geom_line() + geom_ribbon(aes(ymin = Equil.pop - Equil.pop.se, ymax = Equil.pop + Equil.pop.se), alpha = 0.35) + theme_bw()
```

Trying the same plot but a higher rate of catch: $h = 0.10$ I get,

```{r variance_high, echo = FALSE, fig.width=10, fig.height=5}
subData <- subset(allData,harvest == 0.10 )
pd <- position_dodge(.1)
ggplot(subData, aes(x = speed, y = Equil.pop))+ facet_wrap(~management) + geom_line() + geom_ribbon(aes(ymin = Equil.pop - Equil.pop.se, ymax = Equil.pop + Equil.pop.se), alpha = 0.35) + theme_bw()
```

The relevant section of parameter space is shown below

```{r sub, echo=FALSE,fig.width=15, fig.height=5}
subData <- subset(allData,harvest > 0.05 & harvest < 0.13 & management == "consMPA" & speed < 0.3)
contourplot(Equil.pop ~ speed * harvest, data = subData, region = TRUE, drape = TRUE)
```

The next step is to run a few of these simulations and save entire outputs (biomass over space/time). Will do $h = 0.10, s = 0.02-0.07$ 

```{r sim, echo=FALSE,fig.keep='none',message=FALSE,results='hide'}
setwd("/Users/efuller/Documents/Projects/Moving_fish/MovingFish/Simluations/Aspatial_fast")
source("Parameters.R")
source("Functions.R")
require(zoo)
require(plyr)
require(reshape2)
require(lattice)

# adding in subset of parameters, so instead of running Parameters_nothresh.R, am manually entering
  harvests = 0.1
  speeds = seq(0.02,0.1,.01)
  MPA = "cons"

# setting up correct MPA
  if(MPA=="cons") {mpa.yes=cons.yes; mpa.no=cons.no} else {
    if(MPA=="fish") {mpa.yes=fish.yes; mpa.no=fish.no} else {
  		if(MPA=="null") {mpa.yes=null.yes; mpa.no=null.no} else{
  			if(exists("MPA")) warning(paste("MPA needs to be 'cons', 'fish', or 'null'.",sep=""))
  		}
  	}
  }

# initialize the world, set MPA
  output <- startOut(w,maxt,mpa.yes,mpa.no,world)
	init <- output[[1]]
	MPA.start <- output[[2]]

# standard for equilibrium is the difference in the final step of the initialization 
  init.diff <- diff(colSums(init))[(maxt-1)]

# pre-allocating list to save simulations

sims <- vector("list", length(speeds))
times <- vector("list", length(speeds))

for(q in 1:length(speeds)){
  
  for(j in 1:length(harvests)){
    init.h<-array(0,c(w,1))
    next.pop <- m(n=init[,maxt], s = 0, Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.start)
    init.h[,1]=next.pop[[1]]
    MPA.current = next.pop[[3]]
    h.diff <- abs(sum(init[,maxt]-init.h[,1]))
    roll.mean = 1  # set to start
    
    T = 1
    
    while(h.diff > init.diff | roll.mean > init.diff){
      T = T + 1
      next.pop <- m(n=init.h[,T-1], s = 0, Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
      init.h <- cbind(init.h,next.pop[[1]])
      MPA.current <- next.pop[[3]]
      h.diff <- abs(sum(init.h[,T]-init.h[,T-1]))
      if(ncol(init.h) > 100){
      	rolls <- rollmean(colSums(init.h), k = move_window)
      	diff.rolls <- diff(rolls)
		    roll.mean <- diff.rolls[length(diff.rolls)]
    }
    }
    # add in moving climate
    move <- array(0,c(w,1))
    next.pop <- m(n=init.h[,T], s = speeds[q], Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
    move[,1] <- next.pop[[1]]
    MPA.current <- next.pop[[3]]
    h.diff <- abs(sum(init.h[,T]-move[,1]))
    roll.mean = 1 # reset
    
    T = 1
    
    while(h.diff > init.diff & roll.mean > init.diff){
      T = T + 1
      next.pop <- m(n=move[,T-1], s = speeds[q], Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
      
      move <- cbind(move, next.pop[[1]])
      MPA.current <- next.pop[[3]]
      h.diff <- abs(sum(move[,T]-move[,T-1]))
      if(ncol(move) > 300){
      	rolls <- rollmean(colSums(move), k = move_window)
      	diff.rolls <- diff(rolls)
		roll.mean <- diff.rolls[length(diff.rolls)]
		print(T)
    }
    }
       
      # simulate for 300 steps after equilibrium and take average
      harv <- vector(mode = 'logical', length = 300)
      for (i in (T+1):(T+300)){
        next.pop <- m(n=move[,i-1], s = speeds[q], Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
        move <- cbind(move, next.pop[[1]])
        MPA.current = next.pop[[3]]
        harv[(i-T)] <- sum(next.pop[[2]])

      }
    }
  
  sims[[q]] = move[,(ncol(move)-299):ncol(move)]
}

# save the time series of population abundance 
  series <- llply(sims,colSums)
  df <- melt(series)
  names(df) <- c("sums","speed")
  df$speed=factor(df$speed)
  df$time <- rep(seq(1,300),9)
```
After re-running the model, can see that it replicates the pattern of fluctuating total biomas
```{r final-plot,echo=FALSE,message=FALSE,results='hide'}
finals <- llply(series,mean)
df_finals <- melt(finals)
names(df_finals) <- c("totalPop","Speed")
df_finals$Speed = speeds
xyplot(totalPop ~ Speed, data=df_finals,type='l',lwd=2,xlab="Speed")
```
And when you look at the time-series population trends, it's as we expected. All the populations have the same pattern, that they oscillate up and down depending on whether or not they're in a reserve, but the slowest speeds go through the biggest oscillations which means that the average population is much lower. However I wonder if just extending the number of time steps over which I run the average would reduce this effect. 
```{r time-series,echo=FALSE,message=FALSE,results='hide'}
  xyplot(sums ~ time | factor(speed), data = df, type='l',xlab="time",ylab="Population biomass",lwd=2)
```
After re-running the simulation (this time with 600 time steps for equilibrium)
```{r second-sim,echo=FALSE,fig.keep='none',message=FALSE,results='hide'}
# pre-allocating list to save simulations

sims2 <- vector("list", length(speeds))
times2 <- vector("list", length(speeds))

for(q in 1:length(speeds)){
  
  for(j in 1:length(harvests)){
    init.h<-array(0,c(w,1))
    next.pop <- m(n=init[,maxt], s = 0, Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.start)
    init.h[,1]=next.pop[[1]]
    MPA.current = next.pop[[3]]
    h.diff <- abs(sum(init[,maxt]-init.h[,1]))
    roll.mean = 1  # set to start
    
    T = 1
    
    while(h.diff > init.diff | roll.mean > init.diff){
      T = T + 1
      next.pop <- m(n=init.h[,T-1], s = 0, Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
      init.h <- cbind(init.h,next.pop[[1]])
      MPA.current <- next.pop[[3]]
      h.diff <- abs(sum(init.h[,T]-init.h[,T-1]))
      if(ncol(init.h) > 100){
        rolls <- rollmean(colSums(init.h), k = move_window)
      	diff.rolls <- diff(rolls)
		    roll.mean <- diff.rolls[length(diff.rolls)]
    }
    }
    # add in moving climate
    move <- array(0,c(w,1))
    next.pop <- m(n=init.h[,T], s = speeds[q], Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
    move[,1] <- next.pop[[1]]
    MPA.current <- next.pop[[3]]
    h.diff <- abs(sum(init.h[,T]-move[,1]))
    roll.mean = 1 # reset
    
    T = 1
    
    while(h.diff > init.diff & roll.mean > init.diff){
      T = T + 1
      next.pop <- m(n=move[,T-1], s = speeds[q], Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
      
      move <- cbind(move, next.pop[[1]])
      MPA.current <- next.pop[[3]]
      h.diff <- abs(sum(move[,T]-move[,T-1]))
      if(ncol(move) > 300){
      	rolls <- rollmean(colSums(move), k = move_window)
      	diff.rolls <- diff(rolls)
		roll.mean <- diff.rolls[length(diff.rolls)]
		print(T)
    }
    }
       
      # simulate for 600 steps after equilibrium and take average
      harv <- vector(mode = 'logical', length = 600)
      for (i in (T+1):(T+600)){
        next.pop <- m(n=move[,i-1], s = speeds[q], Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
        move <- cbind(move, next.pop[[1]])
        MPA.current = next.pop[[3]]
        harv[(i-T)] <- sum(next.pop[[2]])

      }
    }
  
  sims2[[q]] = move[,(ncol(move)-599):ncol(move)]
}

# save the time series of population abundance 
  series2 <- llply(sims2,colSums)
  df2 <- melt(series2)
  names(df2) <- c("sums","speed")
  df2$time <- rep(seq(1,600),length(speeds))
```

```{r plots,echo=FALSE,message=FALSE,results='hide'}
  xyplot(sums ~ time | factor(speed), data = df2, type='l',xlab="time",ylab="Population biomass",lwd=2)

finals2 <- llply(series2,mean)
df_finals2 <- melt(finals2)
names(df_finals2) <- c("totalPop","Speed")
df_finals2$Speed = speeds

xyplot(totalPop ~ Speed, data=df_finals2,type='l',lwd=2,xlab="Speed")
```

This seems to matter a little bit

```{r compare,echo=FALSE,message=FALSE,results='hide'}
plot(speeds,df_finals$totalPop,pch=19,type="o",main="Mean")
lines(speeds,df_finals2$totalPop,col="red",type="o",pch=19)
```

This is weird, shouldn't be like this, not sure why it is. Needs more work. Next step is to try 900 steps to see if the equilibrium varies

```{r thirdSim, echo=FALSE,fig.keep='none'}

sims3 <- vector("list", length(speeds))

for(q in 1:length(speeds)){
  
  for(j in 1:length(harvests)){
    init.h<-array(0,c(w,1))
    next.pop <- m(n=init[,maxt], s = 0, Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.start)
    init.h[,1]=next.pop[[1]]
    MPA.current = next.pop[[3]]
    h.diff <- abs(sum(init[,maxt]-init.h[,1]))
    roll.mean = 1  # set to start
    
    T = 1
    
    while(h.diff > init.diff | roll.mean > init.diff){
      T = T + 1
      next.pop <- m(n=init.h[,T-1], s = 0, Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
      init.h <- cbind(init.h,next.pop[[1]])
      MPA.current <- next.pop[[3]]
      h.diff <- abs(sum(init.h[,T]-init.h[,T-1]))
      if(ncol(init.h) > 100){
        rolls <- rollmean(colSums(init.h), k = move_window)
        diff.rolls <- diff(rolls)
		    roll.mean <- diff.rolls[length(diff.rolls)]
    }
    }
    # add in moving climate
    move <- array(0,c(w,1))
    next.pop <- m(n=init.h[,T], s = speeds[q], Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
    move[,1] <- next.pop[[1]]
    MPA.current <- next.pop[[3]]
    h.diff <- abs(sum(init.h[,T]-move[,1]))
    roll.mean = 1 # reset
    
    T = 1
    
    while(h.diff > init.diff & roll.mean > init.diff){
      T = T + 1
      next.pop <- m(n=move[,T-1], s = speeds[q], Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
      
      move <- cbind(move, next.pop[[1]])
      MPA.current <- next.pop[[3]]
      h.diff <- abs(sum(move[,T]-move[,T-1]))
      if(ncol(move) > 300){
      	rolls <- rollmean(colSums(move), k = move_window)
      	diff.rolls <- diff(rolls)
		roll.mean <- diff.rolls[length(diff.rolls)]
		print(T)
    }
    }
       
      # simulate for 600 steps after equilibrium and take average
      harv <- vector(mode = 'logical', length = 900)
      for (i in (T+1):(T+900)){
        next.pop <- m(n=move[,i-1], s = speeds[q], Fharv=harvests[j], mpa.yes = mpa.yes, mpa.no = mpa.no, MPA.current = MPA.current)
        move <- cbind(move, next.pop[[1]])
        MPA.current = next.pop[[3]]
        harv[(i-T)] <- sum(next.pop[[2]])

      }
    }
  
  sims3[[q]] = move[,(ncol(move)-899):ncol(move)]
}

# save the time series of population abundance 
  series3 <- llply(sims3,colSums)
  df3 <- melt(series3)
  names(df3) <- c("sums","speed")
  df3$time <- rep(seq(1,900),length(speeds))
```

```{r plots3,echo=FALSE,message=FALSE,results='hide'}
  xyplot(sums ~ time | factor(speed), data = df3, type='l',xlab="time",ylab="Population biomass",lwd=2)

finals3 <- llply(series3,mean)
df_finals3 <- melt(finals3)
names(df_finals3) <- c("totalPop","Speed")
df_finals3$Speed = speeds

xyplot(totalPop ~ Speed, data=df_finals3,type='l',lwd=2,xlab="Speed")
```